0.  Set environment
  https://kubernetes.io/docs/reference/kubectl/cheatsheet/

2.  Creating a Pod
- kubectl creaet ns mynamespace
  kubectl create ns mynamespace; kubectl run elephent --image redis --limits 'cpu=1000m,memory=200Mi' --namespace mynamespace
  https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/
  https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/

apiVersion: v1
kind: Pod
metadata:
  name: elephent
  namespace: mynamespace
spec:
  restartPolicy: OnFailure
  containers:
  - name: redis
    image: redis
    resources:
      requests:
        memory: "200Mi"
        cpu: "1000m"
- https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  https://kubernetes.io/docs/concepts/workloads/pods/

apiVersion: v1
kind: Pod
metadata:
  name: super-user-pod
spec:
  containers:
  - name: busybox
    image: busybox:1.28
    command: ['sh', '-c', 'sleep 3600']
    securityContext:
      capabilities:
        add: ["SYSTEM_TIME"]

3.  Creating a Pod with an init container
- https://kubernetes.io/docs/concepts/workloads/pods/init-containers/

apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox:1.28
    command: ['sh', '-c', 'sleep 10000']
  initContainers:
  - name: init-myservice
    image: busybox:1.28
    command: ['sh', '-c', "mkdir /data && touch /data/runfile.txt"]

4. Configure storage
- https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume
  https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/

apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-1
spec:
  capacity:
    storage: 3Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
  namespace: myvol
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi

  kubectl create ns myvol

apiVersion: v1
kind: Pod
metadata:
  name: pv-pod
  namespace: myvol
spec:
  volumes:
    - name: task-pv-storage
      persistentVolumeClaim:
        claimName: my-pvc
  containers:
    - name: task-pv-container
      image: busybox
      volumeMounts:
        - mountPath: "/data"
          name: task-pv-storage

5. Running a Pod once
-   https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/

kubectl create ns run-once; kubectl run xxazz-pod --image alpine --namespace run-once --restart Never --command -- sh -c "sleep 3600"

apiVersion: v1
kind: Pod
metadata:
  name: xxazz-pod
  namespace: run-once
spec:
  restartPolicy: Never
  containers:
  - name: alpine
    image: alpine
    command: ['sh', '-c', 'sleep 3600']

6. Managing Updates
- https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
  https://kubernetes.io/docs/reference/kubectl/cheatsheet/

  kubectl create deployment nginx-deploy --image nginx:1.14 --replicas 1 --dry-run -o yaml > nginx-deploy.yaml
  kubectl create -f nginx-deploy.yaml
  kubectl set image deployment/nginx-deploy --image nginx --record
  kubectl kubectl rollout history deployment/nginx-deploy
  kubectl rollout undo deployment/nginx-deploy

7. Using Labels
- kubectl get all -A --selector k8s-app=kube-dns

8. Using ConfigMaps
- https://kubernetes.io/docs/concepts/configuration/configmap/

  kubectl create configmap test-cm --from-literal myuser=mypassword

apiVersion: v1
kind: Pod
metadata:
  name: configmap-pod
spec:
  containers:
    - name: alpine
      image: alpine
      command: ['sh', '-c', 'echo $myuser']
      env:
        - name: myuser
          valueFrom:
            configMapKeyRef:
              name: test-cm
              key: myuser

9. Running parallel Pods
- https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/

apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: nginx-daemonset
spec:
  selector:
    matchLabels:
      name: nginx-daemonset
  template:
    metadata:
      labels:
        name: nginx-daemonset
    spec:
      containers:
      - name: nginx
        image: nginx

10. Marking a node as unavailable
- kubectl drain k8s-node-2 --ignore-daemonsets --force
  kubectl uncordon k8s-node-2

11. Using Maintenance Mode
- kubectl cordon k8s-node-1
  kubectl uncordon k8s-node-1

12. Backing up the Etcd Database
- https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/

ETCDCTL_API=3 etcdctl --endpoints 127.0.0.1:2379 \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  snapshot save /var/exam/etcd-backup

ETCDCTL_API=3 etcdctl --endpoints 127.0.0.1:2379 \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --write-out=table snapshot status /var/exam/etcd-backup

13. Using DNS
- kubectl run busybox33 --image busybox:1.28 --command -- sh -c "sleep 3600"
  kubectl expose pod --port 3333

14. Configure a Node to autostart a Pod
- ssh k8s-node2
  kubectl run auto-run --image nginx -o yaml > /etc/kubernetes/manifests/auto-web.yaml

15. Finding the Pod with the highest CPU load
- https://github.com/kubernetes-sigs/metrics-server
  kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
  kubectl edit deployment metrics-server -n kube-system

  Configuration:
    --kubelet-preferred-address-types - The priority of node address types used when determining an address for connecting 
      to a particular node (default [Hostname,InternalDNS,InternalIP,ExternalDNS,ExternalIP])
    --kubelet-insecure-tls - Do not verify the CA of serving certificates presented by Kubelets. For testing purposes only.

  https://kubernetes.io/docs/reference/kubectl/cheatsheet/
  kubectl top pod -A --sort-by=cpu

16. Create NetworkPolicy
- https://kubernetes.io/docs/concepts/services-networking/network-policies/

apiVersion: v1
kind: Namespace
metadata:
  name: secure
  labels:
    type: secure


kubectl run busybox --image busybox --labels type=monitoring --namespace secure; kubectl run nginx --image nginx --labels type=web

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      type: web
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          type: secure
    - podSelector:
        matchLabels:
          type: monitoring

17. Configure a HA Cluster
- https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

18. Create user